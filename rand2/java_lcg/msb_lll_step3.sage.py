

# This file was *autogenerated* from the file msb_lll_step3.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0x5DEECE66D = Integer(0x5DEECE66D); _sage_const_0xB = Integer(0xB); _sage_const_1 = Integer(1); _sage_const_48 = Integer(48); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_20 = Integer(20); _sage_const_50 = Integer(50); _sage_const_32 = Integer(32)
import random
import sys
import ctypes

# https://crypto.stackexchange.com/questions/37836/problem-with-lll-reduction-on-truncated-lcg-schemes

class LCG:
    multiplier = _sage_const_0x5DEECE66D 
    addend = _sage_const_0xB 
    mask = (_sage_const_1  << _sage_const_48 ) - _sage_const_1 
    seed = _sage_const_0 

    def __init__(self, seed):
        self.seed = (seed ^ self.multiplier) & self.mask
    
    def set_seed(self, seed):
        self.seed = seed

    def next(self, bits):
        self.seed = (self.seed * self.multiplier + self.addend) & self.mask
        return self.seed >> (_sage_const_48 -bits)

def main(bits, original):
    N = len(original)-_sage_const_1 

    for i in range(len(original)):
        original[i] = original[i] << (_sage_const_48 -bits)

    lcg = LCG(_sage_const_0 )

    ys = []
    for i in range(N):
        ys.append((original[i+_sage_const_1 ] - original[i]) % (_sage_const_1  << _sage_const_48 ))

    a = _sage_const_0x5DEECE66D 
    c = _sage_const_0xB 

    M = (_sage_const_1  << _sage_const_48 )

    ys = vector(ZZ, ys)
    mat = -matrix.identity(N)

    for i in range(N):
        row = list(mat[i])
        if i == _sage_const_0 :
            row[_sage_const_0 ] = M
        else:
            row[_sage_const_0 ] = (a ** (i))
        mat[i] = vector(ZZ, row)


    mat = mat.LLL()

    W1 = mat * ys
    W2 = vector([ round(RR(w) / M) * M - w for w in W1 ])

    Z = mat.solve_right(W2)
    zs = Z + ys

    z = int(zs[_sage_const_0 ])

    var('x')
    cands = solve_mod((a-_sage_const_1 )*x == (z-c), M)

    for cand in cands:
        cand = cand[_sage_const_0 ]
        lcg = LCG(_sage_const_0 )
        lcg.set_seed(int(cand))
        check = []
        for i in range(N):
            check.append(lcg.next(bits) << (_sage_const_48 -bits))
        if check == original[_sage_const_1 :]:
            return lcg

bits = _sage_const_4 
lcg = LCG(_sage_const_0 )
original = []

args = sys.argv
for i in range(_sage_const_20 ):
    original.append(int(args[i+_sage_const_1 ]))

lcg2 = main(bits, original)

output = []
for i in range(_sage_const_50 ):
    output.append(ctypes.c_int32(lcg2.next(_sage_const_32 )).value)
print("next:", output)

