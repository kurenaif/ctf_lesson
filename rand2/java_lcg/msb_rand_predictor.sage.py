

# This file was *autogenerated* from the file msb_rand_predictor.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0x5DEECE66D = Integer(0x5DEECE66D); _sage_const_0xB = Integer(0xB); _sage_const_1 = Integer(1); _sage_const_48 = Integer(48); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_21 = Integer(21); _sage_const_20 = Integer(20); _sage_const_50 = Integer(50); _sage_const_32 = Integer(32)
import random
import sys
import ctypes

# https://crypto.stackexchange.com/questions/37836/problem-with-lll-reduction-on-truncated-lcg-schemes
# usage: sage msb_lll_step3.sage 0 11 4 7 12 3 3 8 4 7 8 0 9 2 9 7 2 8 5 8

class LCG:
    multiplier = _sage_const_0x5DEECE66D 
    addend = _sage_const_0xB 
    mask = (_sage_const_1  << _sage_const_48 ) - _sage_const_1 
    seed = _sage_const_0 

    def __init__(self, seed):
        self.seed = (seed ^ self.multiplier) & self.mask
    
    def set_seed(self, seed):
        self.seed = seed

    def next(self, bits):
        self.seed = (self.seed * self.multiplier + self.addend) & self.mask
        return self.seed >> (_sage_const_48 -bits)

def main(bits, y):
    N = len(y)-_sage_const_1 

    for i in range(len(y)):
        y[i] = y[i] << (_sage_const_48 -bits)

    ydashes = []
    for i in range(N):
        ydashes.append((y[i+_sage_const_1 ] - y[i]) % (_sage_const_1  << _sage_const_48 ))

    a = _sage_const_0x5DEECE66D 
    c = _sage_const_0xB 
    M = (_sage_const_1  << _sage_const_48 )

    ydashes = vector(ZZ, ydashes)
    A = -matrix.identity(N)

    for i in range(N):
        row = list(A[i])
        if i == _sage_const_0 :
            row[_sage_const_0 ] = M
        else:
            row[_sage_const_0 ] = (a ** (i))
        A[i] = vector(ZZ, row)


    A = A.LLL()

    k = vector(ZZ, [round(RR(w) / M) for w in (A * ydashes)])
    W2 = k * M - A*ydashes

    edash = A.solve_right(W2)
    xdashes = edash + ydashes

    var('x')
    cands = solve_mod((a-_sage_const_1 )*x == (int(xdashes[_sage_const_0 ])-c), M)

    for cand in cands:
        cand = cand[_sage_const_0 ]
        lcg = LCG(_sage_const_0 )
        lcg.set_seed(int(cand))
        check = []
        for i in range(N):
            check.append(lcg.next(bits) << (_sage_const_48 -bits))
        if check == y[_sage_const_1 :]:
            return lcg

bits = _sage_const_4  # top 4 bits

args = sys.argv
if len(args) < _sage_const_21 :
    print(f"usage: {args[0]} rand0 rand1 rand2 ... rand19")
    print(f"example: {args[0]} 1 13 1 14 5 13 3 12 12 8 1 2 7 0 6 15 14 11 14 6")
    sys.exit(_sage_const_1 )

y = []
for i in range(_sage_const_20 ):
    y.append(int(args[i+_sage_const_1 ]))

lcg = main(bits, y)
output = []
for i in range(_sage_const_50 ):
    output.append(ctypes.c_int32(lcg.next(_sage_const_32 )).value)
print("next:", output)

